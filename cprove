#!/bin/env perl

use v5.14;    # or later

use warnings;
use strict;

use Cwd;

use constant TEST_SUITE_VERSION => 'v5.24.1';
use constant KNOWN_ERRORS       => 't/' . TEST_SUITE_VERSION . '/C-COMPILED/known_errors.txt';

my @BLACKLIST = ( 
    qw{benchmark perf porting bigmem lib win32 japh porting run test_pl op/threads.t},
    qr{_thr\.t$}, # do not care about threads
    ); 

push @BLACKLIST, qw{re/uniprops.t op/pack.t}; # FIXME broken for now

run(@ARGV) unless caller;

sub run {
    my (@args) = @_;

    my @copy_args = @args;

    my $v = TEST_SUITE_VERSION;

    return usage() if !scalar @args || grep { $_ =~ qr{^-+h(elp)?$} } @args;

    # need to run with . in INC
    $ENV{PERL_USE_UNSAFE_INC} = 1;

    #$run_compile_version = grep { qr{^-+c(ompiled)?$} } @args;
    my $run_compile_version = !grep { $_ =~ qr{^-+u(ncompiled)?$} } @args;
    @args                = grep  { $_ !~ qr{^-+u(ncompiled)?$} } @args;

    my $saving_state;
    if ( !grep { $_ =~ qr{^--state} } @args ) {
        unshift @args, '--state=save';
        unlink '.prove';
        $saving_state = 1;
    }
    if ( grep { $_ =~ qr{^-+errors?$} } @args ) {
        push @args, load_error_tests();
        @args = grep { $_ !~ qr{^-+errors?$} } @args;
    }

    if ( grep { $_ =~ qr{^-+(git|new)$} } @args ) {
        push @args, load_new_error_tests();
        @args = grep { $_ !~ qr{^-+(git|new)$} } @args;
    }

    if ( grep { $_ eq '--all' } @args ) {
        exec($^X, $0, '-j10', glob q{t/v5.22.*/C-COMPILED/*/*.t});
        die "Exec error: $!"; # should never be reached
    }

    my $restart = sub {
        my $cwd        = cwd();
        my $no_restart = !$saving_state;

        # do not restart the test if -v was already used
        $no_restart ||= grep { $_ =~ qr{^\-+v} } @copy_args;

        # only preserve options except -j and verbose
        my @args = grep { $_ =~ qr{^\-} && $_ !~ qr{^\-\-?[jv]} } @copy_args;
        unshift @args, '-v';
        my @cmd = ( $0, '--state=failed', @args );

        return sub {

            # cannot rerun if we do not save the state
            return if $no_restart;
            $ENV{VERBOSE} = 1;
            print "# Rerunning failures with verbose on\n";
            print join( ' ', '#', '>', @cmd, "\n" );
            chdir($cwd);
            exec @cmd;
        };
      }
      ->();

    my @tests;
    while ( $args[-1] && $args[-1] =~ m/\.t$/ ) {
        my $t = pop @args;

        # can simply run 'prove op/kvaslice.t'
        if ( $t !~ qr{\Q/$v/\E} ) {
            $t = 't/' . $v . '/t/' . $t;
        }

        $t =~ s{C-COMPILED}{t};    # normalize

        my ( $before, $after ) = split( $v . '/t/', $t );
        if ($run_compile_version) {
            $t = $before . $v . '/C-COMPILED/' . $after;
        }
        else {
            $t = $after;           # need to chdir for the uncompiled version
        }
        # remove blacklisted tests
        next if grep {
            ref $_  ? ( $t =~ $_ )
            : ( $t =~ qr{^$_/} or $t eq $_ )
            } @BLACKLIST;
        #die "Cannot find a test file" unless -e $t;
        unshift @tests, $t;
    }

    my @cmd = ( 'prove', @args, @tests );
    if ( @cmd <= 1 ) {
        say "# Nothing to run";
        return 0;
    }

    say "# Running: ", join( ' ', @cmd );
    if ( !$run_compile_version ) {
        chdir("t/$v/t");    # core tests need to be run from t directory
    }

    # allow glob...
    system( join ' ', @cmd );
    $restart->() if $run_compile_version && $?;

    return 1;
}

# cprove --new only run new errors detected on the file
sub load_new_error_tests {
    my $db = KNOWN_ERRORS;
    my @result = split /\n/, qx{git diff --unified=0 $db};

    my %tests;
    foreach my $line (@result) {
        next if $line =~ qr{^(\-\-\-|\+\+\+)\s};
        next unless $line =~ s{^(\-|\+)}{};
        if ( $line =~ qr{([^\s]+\.t)\s} ) {
            $tests{$1} = 1;
        }
    }

    return sort keys %tests;
}

sub load_error_tests {
    my @tests;

    open( my $fh, '<', KNOWN_ERRORS ) or die;
    while ( my $line = <$fh> ) {
        next if $line =~ qr{^\s*#};
        if ( $line =~ qr{^([^\s]+\.t)\s} ) {
            push @tests, $1;
        }
    }

    return @tests;
}

sub usage {

    print <<'EOS';
# run the compiled version
> cprove -j4 t/v5.24.1/t/*.t
> cprove t/v5.24.1/C-COMPILED/op/my.t

# run everything in parallel
> cprove --all
> cprove -j10 t/v5.22.*/C-COMPILED/*/*.t

# run the uncompiled version
> cprove -u -j4 t/v5.24.1/t/*/*.t
> cprove -u t/v5.24.1/C-COMPILED/op/my.t

# run the compiled version
> cprove op/my.t

# run the uncompiled version
> cprove -u -v op/my.t

# run multiple compiled tests
> cprove op/*.t

# run only tests known as broken
> cprove --errors

# run new errors detected by a git diff
> cprove --new
or
> cprove --git

EOS

    return 0;
}
